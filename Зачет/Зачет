Боренко Анастасия ИУ7_32Б

ПЕРВЫЙ ВОПРОС
Вариант 3. Описать функцию, которая добавляет в конец списка L1 все элементы списка L2.

// Структура узла списка
typedef struct node_t node_t;
struct node_t
{
	element_t element;   // Любой тип элемента
	node_t *next;
}

// Без копирования элементов
// На вход - указатель на голову списка 1, и голова списка 2
void add_orig_elements(node_t **l1_head, node_t *l2_head)
{
	// Дойти до последнего элемента списка l1
	node_t *cur= *l1_head;
	for (; cur->next; cur = cur->next);
	
	// Присоеденить голову списка 2 к концу списка 1
	cur->next = l2_head;
}

// С копированием элементов

#define OK 0
#define ERR_CREATE 1
// Создать новый узел списка
int create_node(node_t **new_node)
{
	// Выделить память
	*new_node = calloc(1, sizeof(new_node);
	// Проверить корректность выделения памяти
	if (*new_node == NULL)
		return ERR_CREATE;
	// Сделать каатель на следущий элемент NULL
	(*new_node)-> next = NULL;
	return OK;
}
// Добавить элементы из списка 2 в список 1 с копированием
void add_copy_elements(node_t **l1_head, node_t *l2_head)
{
	// Дойти до последнего элемента списка l1
	node_t *cur= *l1_head;
	// Пока указатель на следущий не NULL перебираем элементы списка 1
	for (; cur->next; cur = cur->next); 
	
	// Скопировать элементы l2 в l1
	node_t *buf;
	for (node_t *cur_l2 = l2_head; cur_l2; cur_l2 = cur_l2->next);
	{
		// Создать новый узел списка
		rc = create_node(&buf);
		// В случае некорретного выделения памяти прекратить работу
		if (rc != OK)
			return;
			
		// Скопировать элемент в этот узел списка
		buf->element = cur_l2->element;
		// Добавить элемент в список 1
		cur->next = buf;
		// Перейти курсором на новый последний элемент списка 1
		cur = buf;
	}
}


ВТОРОЙ ВОПРОС

1. Что такое коллизия?
Конфликт в хеш-таблицах, один хеш-адрес для нескольких разных ключей.

2. Дескриптор стека, реализованного на основе массива.
	Имя 
	Адрес первого элемента
	Индекс первого элемента
	Индекс последнего элемента
	Тип элемента
	Длина элемента

3. Какие виды деревьев мы рассматривали в лекциях?
	Дерево двоичного поиска
	Бинарное дерево
	Идеально Сбалансированное
	АВЛ
	
4. Примеры использования многосвязных нелинейных списков

5. Требования, предъявляемые к хеш-функциям
	Простота (чтобы быстро считалась)
	Использовать все адресное пространство с одинаковой вероятностью;
	Всегда возвращать один и тот же адреc для одного и того же ключа;
	
6. За счет чего проявляется эффективность обработки разреженных матриц при разреженной схеме хранения
	Обрабатываются только ненулевые элементы

7. В какой (каких) лабораторной работе использовалось и применялось понятие АТД?
	Лр 6,7

8. Сколько дополнительной памяти потребуется в дескрипторе при описании матрицы А [-1..4,2..3] для хранения векторов Айлиффа? 
	2 ячейки памяти (для хранения указателей на описание столбцов, матрица читается по столбцам)
	5 ячеек памяти (для хранения указателей на описание строк, матрица читается по строкам)

9. Пример неверного применения рекурсивного алгоритма. Указать почему.

	Рекурсия без подсчета степени вложенности

10. Какие структуры определяются только доступом к определенным элементам.
	Стеки
	Очереди

11. Какие самые быстрые алгоритмы поиска элемента мы рассматривали в лекциях?
	Поиск в двоичном дереве
	
12. Чем отличается поиск в АВЛ дереве и в идеально сбалансированном дереве?

13. Какие рекурсивные СД вы знаете? Приведите пример на Си
	Списки
	struct node_t 
	{
		element;
		node_t *next;
	}
	
14. 
	сбалансированное и сильно ветвистое.
	Элементы меньше узла слево от узла

15. 
	Способы устранения колизий
		открытое хеширование - с помощью спиков, цепочек
		закрытое - запись после занятой ячейки
		
16. 
	Счетчик вложенности

17. 

18.
В зависимости от ситуации
	Массив - не надо бежать от головы до нужного элемента
	Список - нет операции разиндексации

19. 
	В графах

20. 
	Оперативная память
	Кеш память (Разных уровней)
	
21. 
	Кол-во вызовов функции на N кол-во элементов
	
22. 
	Динамическая
	Статическая
